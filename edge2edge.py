#! /usr/bin/env python3

import argparse, sys, struct 


Description = """
Convert and possibly transform a matrix in a mtx-like format in a 
simple list of arcs writing to stdout one arc per line in text format
 * optionally shift all node ids by a constant
 * optionally transpose the matrix and/or remove self loops
 * optionally write to a binary file the row and column counts, that is,
   the number of nonzero in each row and column. 

Lines starting with # or % or containing more than 2 items 
are discarded 

The first line non starting with # or % and containing 3 items is
assumed to be a header of the matrix market format and is used to
determine the number of nodes in the mtx file; the actual number of
nodes will be the maximum between that value and the maximum node id
found in the arcs.

A tentative mtx header containing info about the processed 
matrix is written to infile.header; this is useful for
human inspection.

The list of arcs can be further manipulated (for example sorted in 
row major order) and then appended to the header to form a 
possibly valid mtx matrix file (depends on how the arcs are manipulated)

Additional notes:

For matrepair:
  the list of arcs must be stored in row major order; this can achieved
  for example with the command
     sort -u -k 1n -k 2n arcs >  arcs.rm
  where -u removes duplicates, -k 1n -k 2n sorts first on column 1 and then 
  on column 2 in numerical order

For k2sparse:
  the list of arcs does not need to be sorted but there must be no 
  duplicates; the format used for matrepair will work fine  
"""


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description=Description, formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("infile", help="input file", type=str)
    parser.add_argument("-a", help="add offset A to each node id", type=int, default=0)
    parser.add_argument("-c", help="save column counts", action="store_true")
    parser.add_argument("-r", help="save row counts", action="store_true")
    parser.add_argument("-s", help="remove self loops", action="store_true")
    parser.add_argument("-t", help="traspose matrix", action="store_true")
    parser.add_argument("-v", help="verbose output", action="store_true")
    args = parser.parse_args()
    mtx_nodes = -1
    mtx_rce_header = ""
    with open(args.infile) as f:
        row_counts = {}  # row_counts[i] number elements in row i
        col_counts = {}  # col_counts[i] number elements in col i
        maxnode = 0; minnode = 2**32
        arcs = 0; totlines = 0; selfloops = 0
        for line in f:
            totlines += 1
            pair = line.strip().split()
            if pair[0][0] == "%" or pair[0][0] == "#" : continue   # skip rows containing comments
            if mtx_nodes <0  and len(pair) == 3:
                mtx_nodes = max( int(pair[0]), int(pair[1]) ) # number of nodes in mtx file
                mtx_rce_header = line.strip()
                continue
            if len(pair) != 2:
                if args.v: print(f"Line {totlines} discarded:\n  ==> {line}", end="", file=sys.stderr)
                continue
            r= int(pair[0]); c = int(pair[1])
            if args.s and r == c:
                selfloops += 1 
                continue  # self loop
            # transform arc as required and output it
            r += args.a;    c += args.a
            maxnode = max(maxnode, r, c)
            minnode = min(minnode, r, c)
            arcs += 1
            if args.t: (c,r) = (r,c)
            print(r, c)  # output pair
            # count elements in row and column
            if args.c:
                if c not in col_counts: col_counts[c] = 0
                col_counts[c] += 1
            if args.r:
                if r not in row_counts: row_counts[r] = 0
                row_counts[r] += 1;
    # scanning completed: compute number of distinct nodes
    # taking the largest bteewen the largest node id and the number of nodes in the mtx file
    num_nodes = max(maxnode+1, mtx_nodes) 
    # output row/column counts
    header_file = args.infile + ".header"
    if args.v:
      print(f"Matrix Market header in file {header_file}", file=sys.stderr)
    with open(header_file, "w") as f: 
        print(f"%%MatrixMarket matrix coordinate pattern general", file=f)
        print(f"% generated by {sys.argv[0]} from file {args.infile}", file=f)
        print("% Command line:", file=f)
        print("%  "+" ".join(sys.argv), file=f)
        print(f"% Rows Cols Entries from file {args.infile}:", file=f)
        print(f"%   {mtx_rce_header}", file=f)
        print(f"% smallest/largest node id = {minnode}/{maxnode} nonzeros = {arcs} "+
          f"[selfloops={selfloops}]", file=f)
        print(f"{num_nodes} {num_nodes} {arcs}", file=f)
    # save row/column counts if required
    if args.c:
        assert arcs == sum(col_counts.values()), "Inconsistent column count"
        maxcount = max(col_counts.values())
        if maxcount > 2**32 -1:
            print(f"maxcount = {maxcount} is too large. Cannot produce 32-bit column count file",file = sys.stderr )
        else:
            if args.v:
              print(f"Largest column count = {maxcount}", file=sys.stderr)
              print(f"Saving column counts in {args.infile}.ccount", file=sys.stderr)
            with open(args.infile + ".ccount", "wb") as f:
                for i in range(num_nodes):
                    f.write(struct.pack("I", col_counts[i] if i in col_counts else 0))
    if args.r:
        assert arcs == sum(row_counts.values()), "Inconsistent row count"
        maxcount = max(col_counts.values())
        if maxcount > 2**32 -1:
            print(f"maxcount = {maxcount} is too large. Cannot produce 32-bit row count file",file = sys.stderr )
        else:
            if args.v:
              print(f"Largest row count = {maxcount}", file=sys.stderr)
              print(f"Saving row counts in {args.infile}.rcount", file=sys.stderr)
            with open(args.infile + ".rcount", "wb") as f:
                for i in range(maxnode+1):
                    f.write(struct.pack("I", row_counts[i] if i in row_counts else 0))
